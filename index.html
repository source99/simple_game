<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Green Ball Game with D-Pad</title>
  <style>
    body { margin: 0; background: #eee; }
    canvas { display: block; margin: 0 auto; background: #fff; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1024" height="768"></canvas>
  <script>
    // Get canvas and context.
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Canvas dimensions.
    const screenWidth = canvas.width;
    const screenHeight = canvas.height;

    // Define margins and areas.
    const topMargin = 50; // Area at top for scores.
    // We'll use the top half (from y = topMargin to y = screenHeight/2) for gameplay.
    const gameArea = { 
      x: 0, 
      y: topMargin, 
      width: screenWidth, 
      height: Math.floor(screenHeight/2) - topMargin 
    };
    // The bottom half (from y = screenHeight/2 to y = screenHeight) will be our D-Pad area.
    const dpadArea = { 
      x: 0, 
      y: Math.floor(screenHeight/2), 
      width: screenWidth, 
      height: screenHeight - Math.floor(screenHeight/2)
    };

    // Constants.
    const objectMargin = 20;   // Margin for objects inside the game area.
    const minDistance = 150;   // Red obstacles must be at least this far from the green ball.
    const targetSize = 20;
    const redSize = 20;
    const playerInitialWidth = 50;
    const playerInitialHeight = 50;
    const initialPlayerSpeed = 4;
    const bounceMultiplier = 1.1;
    const maxSpeedMultiplier = 5; // End round if speed >= initialPlayerSpeed * 5

    // Scores.
    let currentScore = 0;
    let previousScore = 0;
    let highScore = 0;

    // Define the player (green ball).
    let player = {
      x: randomInt(gameArea.x + objectMargin, gameArea.x + gameArea.width - objectMargin - playerInitialWidth),
      y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - playerInitialHeight),
      width: playerInitialWidth,
      height: playerInitialHeight,
      vx: 0,
      vy: 0
    };

    // Define the blue target.
    let target = {
      x: randomInt(objectMargin, screenWidth - objectMargin - targetSize),
      y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - targetSize),
      width: targetSize,
      height: targetSize
    };

    // Define an array for red obstacles.
    let redObstacles = [];
    // Initially create 2 red obstacles.
    for (let i = 0; i < 2; i++) {
      redObstacles.push(createRedObstacle());
    }

    // Key state.
    const keys = {};
    window.addEventListener("keydown", function(e) {
      keys[e.key] = true;
      if (e.key.toLowerCase() === "q") {
        cancelAnimationFrame(animationFrameId);
      }
    });
    window.addEventListener("keyup", function(e) {
      keys[e.key] = false;
    });

    // Add mobile touch support for both game area and D-Pad.
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      let rectCanvas = canvas.getBoundingClientRect();
      let touchX = touch.clientX - rectCanvas.left;
      let touchY = touch.clientY - rectCanvas.top;
      // If touch is in the D-Pad area, process as D-Pad input.
      if (touchY >= dpadArea.y) {
        processDpadTouch(touchX, touchY);
      } else {
        // Otherwise, move the ball toward the tap (optional, or you can ignore).
        let centerX = player.x + player.width / 2;
        let centerY = player.y + player.height / 2;
        let dx = touchX - centerX;
        let dy = touchY - centerY;
        let len = Math.sqrt(dx*dx + dy*dy);
        if (len > 0) {
          player.vx = (dx / len) * initialPlayerSpeed;
          player.vy = (dy / len) * initialPlayerSpeed;
        }
      }
    });

    // Process D-Pad touch in the bottom half.
    // We'll define four button areas within the D-Pad area.
    const dpadSize = 80; // Size of the D-Pad (square) that we'll draw in the bottom left.
    const dpadX = 10;
    const dpadY = dpadArea.y + 10;
    const upButton = { x: dpadX + dpadSize/3, y: dpadY, width: dpadSize/3, height: dpadSize/3 };
    const leftButton = { x: dpadX, y: dpadY + dpadSize/3, width: dpadSize/3, height: dpadSize/3 };
    const rightButton = { x: dpadX + 2*dpadSize/3, y: dpadY + dpadSize/3, width: dpadSize/3, height: dpadSize/3 };
    const downButton = { x: dpadX + dpadSize/3, y: dpadY + 2*dpadSize/3, width: dpadSize/3, height: dpadSize/3 };

    function processDpadTouch(touchX, touchY) {
      // Check which button rectangle the touch point falls in.
      if (touchX >= upButton.x && touchX <= upButton.x + upButton.width &&
          touchY >= upButton.y && touchY <= upButton.y + upButton.height) {
        // Up
        player.vx = 0;
        player.vy = -initialPlayerSpeed;
      } else if (touchX >= downButton.x && touchX <= downButton.x + downButton.width &&
                 touchY >= downButton.y && touchY <= downButton.y + downButton.height) {
        // Down
        player.vx = 0;
        player.vy = initialPlayerSpeed;
      } else if (touchX >= leftButton.x && touchX <= leftButton.x + leftButton.width &&
                 touchY >= leftButton.y && touchY <= leftButton.y + leftButton.height) {
        // Left
        player.vy = 0;
        player.vx = -initialPlayerSpeed;
      } else if (touchX >= rightButton.x && touchX <= rightButton.x + rightButton.width &&
                 touchY >= rightButton.y && touchY <= rightButton.y + rightButton.height) {
        // Right
        player.vy = 0;
        player.vx = initialPlayerSpeed;
      }
    }

    // Helper: Returns a random integer between min and max (inclusive).
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Helper: Returns a random element from an array.
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    // Helper: Create a red obstacle (object) that is at least minDistance from the green ball.
    function createRedObstacle() {
      let red;
      while (true) {
        red = {
          x: randomInt(objectMargin, screenWidth - objectMargin - redSize),
          y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - redSize),
          width: redSize,
          height: redSize,
          vx: randomChoice([-2, -1, 1, 2]),
          vy: randomChoice([-2, -1, 1, 2])
        };
        let dx = (red.x + red.width/2) - (player.x + player.width/2);
        let dy = (red.y + red.height/2) - (player.y + player.height/2);
        let distance = Math.sqrt(dx*dx + dy*dy);
        if (distance >= minDistance) break;
      }
      return red;
    }

    // Collision detection.
    function collides(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // Global timing variables.
    let lastTime = performance.now();
    let animationFrameId;
    let pauseUntil = 0;

    // Expanded instructions (we'll now also mention the D-pad).
    const instructions = [
      "How to Play:",
      "1. Touch the green ball's D-Pad buttons in the bottom half to move it.",
      "2. Each blue target gives you 1 point.",
      "3. Avoid the drifting red balls—touching one ends the game.",
      "4. The green ball bounces off the walls, growing and speeding up.",
      "5. If its speed reaches 5× its initial speed, the round ends.",
      "",
      "Controls:",
      "• Use the D-Pad (bottom left) or tap elsewhere to move toward that point.",
      "• Q: Quit"
    ];

    // Main game loop.
    function gameLoop() {
      let now = performance.now();
      let deltaTime = now - lastTime;
      lastTime = now;

      if (now < pauseUntil) {
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Update game state.
    function update(deltaTime) {
      // Update player velocity based on keyboard input.
      if (keys["w"] || keys["W"] || keys["ArrowUp"]) {
        player.vx = 0;
        player.vy = -initialPlayerSpeed;
      } else if (keys["s"] || keys["S"] || keys["ArrowDown"]) {
        player.vx = 0;
        player.vy = initialPlayerSpeed;
      } else if (keys["a"] || keys["A"] || keys["ArrowLeft"]) {
        player.vy = 0;
        player.vx = -initialPlayerSpeed;
      } else if (keys["d"] || keys["D"] || keys["ArrowRight"]) {
        player.vy = 0;
        player.vx = initialPlayerSpeed;
      } else if (keys["x"] || keys["X"]) {
        player.vx = 0;
        player.vy = 0;
      }

      // Update player's position.
      player.x += player.vx;
      player.y += player.vy;

      // Bounce the player off the game area edges.
      if (player.x < gameArea.x) {
        player.x = gameArea.x;
        player.vx = -player.vx;
      }
      if (player.x + player.width > gameArea.x + gameArea.width) {
        player.x = gameArea.x + gameArea.width - player.width;
        player.vx = -player.vx;
      }
      if (player.y < gameArea.y) {
        player.y = gameArea.y;
        player.vy = -player.vy;
      }
      if (player.y + player.height > gameArea.y + gameArea.height) {
        player.y = gameArea.y + gameArea.height - player.height;
        player.vy = -player.vy;
      }

      // Check if the player hit an edge exactly.
      let bounced = false;
      if (player.x === gameArea.x || player.x + player.width === gameArea.x + gameArea.width) {
        bounced = true;
      }
      if (player.y === gameArea.y || player.y + player.height === gameArea.y + gameArea.height) {
        bounced = true;
      }
      if (bounced) {
        player.vx *= bounceMultiplier;
        player.vy *= bounceMultiplier;
        let cx = player.x + player.width / 2;
        let cy = player.y + player.height / 2;
        player.width = Math.floor(player.width * bounceMultiplier);
        player.height = Math.floor(player.height * bounceMultiplier);
        player.x = cx - player.width / 2;
        player.y = cy - player.height / 2;
      }

      // Update red obstacles: drift and bounce off game area edges.
      for (let red of redObstacles) {
        red.x += red.vx;
        red.y += red.vy;
        if (red.x < gameArea.x) {
          red.x = gameArea.x;
          red.vx = -red.vx;
        }
        if (red.x + red.width > gameArea.x + gameArea.width) {
          red.x = gameArea.x + gameArea.width - red.width;
          red.vx = -red.vx;
        }
        if (red.y < gameArea.y) {
          red.y = gameArea.y;
          red.vy = -red.vy;
        }
        if (red.y + red.height > gameArea.y + gameArea.height) {
          red.y = gameArea.y + gameArea.height - red.height;
          red.vy = -red.vy;
        }
      }

      // Check collision with red obstacles.
      for (let red of redObstacles) {
        if (collides(player, red)) {
          gameOver();
          return;
        }
      }

      // Check collision with the blue target.
      if (collides(player, target)) {
        currentScore++;
        // Reposition the blue target.
        target.x = randomInt(objectMargin, screenWidth - objectMargin - target.width);
        target.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - target.height);
        // Reposition all red obstacles with new velocities.
        for (let i = 0; i < redObstacles.length; i++) {
          let newRed = createRedObstacle();
          redObstacles[i].x = newRed.x;
          redObstacles[i].y = newRed.y;
          redObstacles[i].vx = randomChoice([-2, -1, 1, 2]);
          redObstacles[i].vy = randomChoice([-2, -1, 1, 2]);
        }
        // After each multiple of 3 points, add a new red obstacle.
        let desiredCount = 2 + Math.floor(currentScore / 3);
        if (redObstacles.length < desiredCount) {
          let newRed = createRedObstacle();
          newRed.vx = randomChoice([-2, -1, 1, 2]);
          newRed.vy = randomChoice([-2, -1, 1, 2]);
          redObstacles.push(newRed);
        }
        // Immediately update display so new positions are shown.
        draw();
        // Pause for 500 ms (half a second) after repositioning.
        pauseUntil = performance.now() + 500;
        return;
      }

      // End round if player's speed reaches 5× the initial speed.
      let speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
      if (speed >= initialPlayerSpeed * maxSpeedMultiplier) {
        gameOver();
        return;
      }

      // Continuous scaling with B and T keys.
      if (keys["b"] || keys["B"]) {
        let cx = player.x + player.width / 2;
        let cy = player.y + player.height / 2;
        player.width += 2;
        player.height += 2;
        player.x = cx - player.width / 2;
        player.y = cy - player.height / 2;
      }
      if (keys["t"] || keys["T"]) {
        if (player.width > 10 && player.height > 10) {
          let cx = player.x + player.width / 2;
          let cy = player.y + player.height / 2;
          player.width -= 2;
          player.height -= 2;
          player.x = cx - player.width / 2;
          player.y = cy - player.height / 2;
        }
      }
    }

    // Draw everything.
    function draw() {
      ctx.clearRect(0, 0, screenWidth, screenHeight);
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      ctx.strokeStyle = "rgb(200,200,200)";
      ctx.strokeRect(gameArea.x, gameArea.y, gameArea.width, gameArea.height);
      ctx.fillStyle = "blue";
      ctx.fillRect(target.x, target.y, target.width, target.height);
      ctx.fillStyle = "red";
      for (let red of redObstacles) {
        ctx.fillRect(red.x, red.y, red.width, red.height);
      }
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.ellipse(player.x + player.width / 2, player.y + player.height / 2, player.width / 2, player.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      // Draw scores in the top margin.
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      let scoreText = `Current Score: ${currentScore}    Previous Game Score: ${previousScore}    High Score: ${highScore}`;
      ctx.fillText(scoreText, 10, 30);
      
      // Draw the D-Pad in the bottom half.
      // D-Pad will be drawn in the bottom left corner of the dpadArea.
      const dpadSize = 80;
      const dpadX = 10;
      const dpadY = dpadArea.y + 10; // dpadArea is the bottom half of the canvas.
      // Define button regions.
      const upButton = { x: dpadX + dpadSize/3, y: dpadY, width: dpadSize/3, height: dpadSize/3 };
      const leftButton = { x: dpadX, y: dpadY + dpadSize/3, width: dpadSize/3, height: dpadSize/3 };
      const rightButton = { x: dpadX + 2*dpadSize/3, y: dpadY + dpadSize/3, width: dpadSize/3, height: dpadSize/3 };
      const downButton = { x: dpadX + dpadSize/3, y: dpadY + 2*dpadSize/3, width: dpadSize/3, height: dpadSize/3 };
      
      // Draw D-Pad background.
      ctx.strokeStyle = "black";
      ctx.strokeRect(dpadX, dpadY, dpadSize, dpadSize);
      // Draw buttons.
      ctx.fillStyle = "gray";
      ctx.fillRect(upButton.x, upButton.y, upButton.width, upButton.height);
      ctx.fillRect(leftButton.x, leftButton.y, leftButton.width, leftButton.height);
      ctx.fillRect(rightButton.x, rightButton.y, rightButton.width, rightButton.height);
      ctx.fillRect(downButton.x, downButton.y, downButton.width, downButton.height);
      
      // Optionally, draw arrow labels.
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.fillText("↑", upButton.x + upButton.width/2 - 5, upButton.y + upButton.height/2 + 5);
      ctx.fillText("←", leftButton.x + leftButton.width/2 - 5, leftButton.y + leftButton.height/2 + 5);
      ctx.fillText("→", rightButton.x + rightButton.width/2 - 5, rightButton.y + rightButton.height/2 + 5);
      ctx.fillText("↓", downButton.x + downButton.width/2 - 5, downButton.y + downButton.height/2 + 5);
      
      // Also draw the instructions (if any) above the D-Pad.
      ctx.font = "16px Arial";
      let instrY = dpadArea.y + dpadSize + 20;
      for (let instr of instructions) {
        ctx.fillText(instr, 10, instrY);
        instrY += 24;
      }
    }

    // Simple busy-wait pause.
    function pause(ms) {
      const start = performance.now();
      while (performance.now() - start < ms) { }
    }

    // Game over: update scores and reset the game.
    function gameOver() {
      previousScore = currentScore;
      if (currentScore > highScore) highScore = currentScore;
      resetGame();
    }

    // Reset game variables for a new round.
    function resetGame() {
      currentScore = 0;
      player.x = randomInt(gameArea.x + objectMargin, gameArea.x + gameArea.width - objectMargin - playerInitialWidth);
      player.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - playerInitialHeight);
      player.width = playerInitialWidth;
      player.height = playerInitialHeight;
      player.vx = 0;
      player.vy = 0;
      target.x = randomInt(objectMargin, screenWidth - objectMargin - targetSize);
      target.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - targetSize);
      redObstacles = [];
      for (let i = 0; i < 2; i++) {
        let red = createRedObstacle();
        red.vx = randomChoice([-2, -1, 1, 2]);
        red.vy = randomChoice([-2, -1, 1, 2]);
        redObstacles.push(red);
      }
    }

    // Start the game loop.
    function gameLoop() {
      let now = performance.now();
      let deltaTime = now - lastTime;
      lastTime = now;
      if (now < pauseUntil) {
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Touch support for D-Pad area.
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      let rectCanvas = canvas.getBoundingClientRect();
      let touchX = touch.clientX - rectCanvas.left;
      let touchY = touch.clientY - rectCanvas.top;
      // If touch is in the D-Pad area, process D-Pad controls.
      if (touchY >= dpadArea.y) {
        // Check which D-Pad button.
        if (touchX >= (dpadX + dpadSize/3) && touchX <= (dpadX + 2*dpadSize/3) &&
            touchY >= dpadY && touchY <= dpadY + dpadSize/3) {
          // Up.
          player.vx = 0;
          player.vy = -initialPlayerSpeed;
        } else if (touchX >= dpadX && touchX <= (dpadX + dpadSize/3) &&
                   touchY >= dpadY + dpadSize/3 && touchY <= dpadY + 2*dpadSize/3) {
          // Left.
          player.vy = 0;
          player.vx = -initialPlayerSpeed;
        } else if (touchX >= (dpadX + 2*dpadSize/3) && touchX <= (dpadX + dpadSize) &&
                   touchY >= dpadY + dpadSize/3 && touchY <= dpadY + 2*dpadSize/3) {
          // Right.
          player.vy = 0;
          player.vx = initialPlayerSpeed;
        } else if (touchX >= (dpadX + dpadSize/3) && touchX <= (dpadX + 2*dpadSize/3) &&
                   touchY >= dpadY + 2*dpadSize/3 && touchY <= (dpadY + dpadSize)) {
          // Down.
          player.vx = 0;
          player.vy = initialPlayerSpeed;
        }
      }
    });

    // Start the game loop.
    gameLoop();

  </script>
</body>
</html>
