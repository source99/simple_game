<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Green Ball Game - No Bounce Scaling</title>
  <style>
    body { margin: 0; background: #eee; }
    /* The canvas fills the entire viewport */
    canvas { display: block; width: 100vw; height: 100vh; background: #fff; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // Use visualViewport if available for true visible area.
    function getScreenDimensions() {
      const width = window.visualViewport ? window.visualViewport.width : window.innerWidth;
      const height = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      return { width, height };
    }

    // Set up the canvas dimensions.
    const dims = getScreenDimensions();
    const screenWidth = dims.width;
    const screenHeight = dims.height;
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = screenWidth;
    canvas.height = screenHeight;
    
    // Define layout:
    // The game area has a fixed 4:3 aspect ratio based on screen width.
    const gameArea = {
      x: 0,
      y: 0,
      width: screenWidth,
      height: screenWidth * 3 / 4
    };
    // The D-Pad area occupies the remaining vertical space.
    const dpadArea = {
      x: 0,
      y: gameArea.height,
      width: screenWidth,
      height: screenHeight - gameArea.height
    };
    
    // Constants.
    const objectMargin = 20;      // Margin for objects inside the game area.
    const minDistance = 150;      // Red obstacles must be at least this far from the green ball.
    const targetSize = 20;
    const redSize = 20;
    const playerInitialWidth = 50;
    const playerInitialHeight = 50;
    const initialPlayerSpeed = 4;
    // When bouncing, we now simply reverse the velocity.
    const maxSpeedMultiplier = 5; // End round if player's speed reaches 5× the initial speed.
    
    // Game scores.
    let currentScore = 0;
    let previousScore = 0;
    let highScore = 0;
    
    // Define the player (green ball).
    let player = {
      x: randomInt(gameArea.x + objectMargin, gameArea.x + gameArea.width - objectMargin - playerInitialWidth),
      y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - playerInitialHeight),
      width: playerInitialWidth,
      height: playerInitialHeight,
      vx: 0,
      vy: 0
    };
    
    // Define the blue target.
    let target = {
      x: randomInt(objectMargin, screenWidth - objectMargin - targetSize),
      y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - targetSize),
      width: targetSize,
      height: targetSize
    };
    
    // Define an array for red obstacles.
    let redObstacles = [];
    for (let i = 0; i < 2; i++) {
      redObstacles.push(createRedObstacle());
    }
    
    // Key state.
    const keys = {};
    window.addEventListener("keydown", function(e) {
      keys[e.key] = true;
      if (e.key.toLowerCase() === "q") {
        cancelAnimationFrame(animationFrameId);
      }
    });
    window.addEventListener("keyup", function(e) {
      keys[e.key] = false;
    });
    
    // Mobile touch support.
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rectCanvas = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rectCanvas.left;
      const touchY = touch.clientY - rectCanvas.top;
      if (touchY >= dpadArea.y) {
        processDpadTouch(touchX, touchY);
      } else {
        const centerX = player.x + player.width / 2;
        const centerY = player.y + player.height / 2;
        const dx = touchX - centerX;
        const dy = touchY - centerY;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          player.vx = (dx / len) * initialPlayerSpeed;
          player.vy = (dy / len) * initialPlayerSpeed;
        }
      }
    });
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rectCanvas = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rectCanvas.left;
      const touchY = touch.clientY - rectCanvas.top;
      if (touchY >= dpadArea.y) {
        processDpadTouch(touchX, touchY);
      } else {
        const centerX = player.x + player.width / 2;
        const centerY = player.y + player.height / 2;
        const dx = touchX - centerX;
        const dy = touchY - centerY;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          player.vx = (dx / len) * initialPlayerSpeed;
          player.vy = (dy / len) * initialPlayerSpeed;
        }
      }
    });
    
    // Process D-Pad touch input for a 3×3 grid.
    function processDpadTouch(touchX, touchY) {
      const cellWidth = dpadArea.width / 3;
      const cellHeight = dpadArea.height / 3;
      const col = Math.floor((touchX - dpadArea.x) / cellWidth);
      const row = Math.floor((touchY - dpadArea.y) / cellHeight);
      if (col === 0) {
        player.vx = -initialPlayerSpeed;
        player.vy = 0;
      } else if (col === 2) {
        player.vx = initialPlayerSpeed;
        player.vy = 0;
      } else {
        if (row === 0) {
          player.vx = 0;
          player.vy = -initialPlayerSpeed;
        } else if (row === 2) {
          player.vx = 0;
          player.vy = initialPlayerSpeed;
        } else {
          player.vx = 0;
          player.vy = 0;
        }
      }
    }
    
    // Helper: Returns a random integer between min and max (inclusive).
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    // Helper: Returns a random element from an array.
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    
    // Helper: Create a red obstacle (object) that is at least minDistance from the green ball.
    function createRedObstacle() {
      let red;
      while (true) {
        red = {
          x: randomInt(objectMargin, screenWidth - objectMargin - redSize),
          y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - redSize),
          width: redSize,
          height: redSize,
          vx: randomChoice([-2, -1, 1, 2]),
          vy: randomChoice([-2, -1, 1, 2])
        };
        const dx = (red.x + red.width / 2) - (player.x + player.width / 2);
        const dy = (red.y + red.height / 2) - (player.y + player.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance >= minDistance) break;
      }
      return red;
    }
    
    // Collision detection.
    function collides(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }
    
    // Global timing variables.
    let lastTime = performance.now();
    let animationFrameId;
    let pauseUntil = 0;
    
    // Expanded instructions.
    const instructions = [
      "How to Play:",
      "1. Use the D-Pad below (3×3 grid) to control the green ball.",
      "2. Touch the blue target to score 1 point.",
      "3. Avoid the drifting red balls – touching one ends the game.",
      "4. The green ball bounces off walls without changing size or speed.",
      "5. If its speed reaches 5× its initial speed, the round ends.",
      "",
      "Controls:",
      "• D-Pad (bottom area):",
      "  - Left third: move left",
      "  - Right third: move right",
      "  - Middle column: top cell = up, bottom cell = down, center = stop",
      "• WASD / Arrow keys (desktop) work too",
      "• Q: Quit"
    ];
    
    // Main game loop.
    function gameLoop() {
      let now = performance.now();
      let deltaTime = now - lastTime;
      lastTime = now;
      if (now < pauseUntil) {
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    // Update game state.
    function update(deltaTime) {
      if (keys["w"] || keys["W"] || keys["ArrowUp"]) {
        player.vx = 0;
        player.vy = -initialPlayerSpeed;
      } else if (keys["s"] || keys["S"] || keys["ArrowDown"]) {
        player.vx = 0;
        player.vy = initialPlayerSpeed;
      } else if (keys["a"] || keys["A"] || keys["ArrowLeft"]) {
        player.vy = 0;
        player.vx = -initialPlayerSpeed;
      } else if (keys["d"] || keys["D"] || keys["ArrowRight"]) {
        player.vy = 0;
        player.vx = initialPlayerSpeed;
      } else if (keys["x"] || keys["X"]) {
        player.vx = 0;
        player.vy = 0;
      }
    
      player.x += player.vx;
      player.y += player.vy;
    
      if (player.x < gameArea.x) {
        player.x = gameArea.x;
        player.vx = -player.vx;
      }
      if (player.x + player.width > gameArea.x + gameArea.width) {
        player.x = gameArea.x + gameArea.width - player.width;
        player.vx = -player.vx;
      }
      if (player.y < gameArea.y) {
        player.y = gameArea.y;
        player.vy = -player.vy;
      }
      if (player.y + player.height > gameArea.y + gameArea.height) {
        player.y = gameArea.y + gameArea.height - player.height;
        player.vy = -player.vy;
      }
    
      let bounced = false;
      if (player.x === gameArea.x || player.x + player.width === gameArea.x + gameArea.width) {
        bounced = true;
      }
      if (player.y === gameArea.y || player.y + player.height === gameArea.y + gameArea.height) {
        bounced = true;
      }
      if (bounced) {
        player.vx = -player.vx;
        player.vy = -player.vy;
        let cx = player.x + player.width / 2;
        let cy = player.y + player.height / 2;
        // No scaling on bounce.
        player.x = cx - player.width / 2;
        player.y = cy - player.height / 2;
      }
    
      for (let red of redObstacles) {
        red.x += red.vx;
        red.y += red.vy;
        if (red.x < gameArea.x) {
          red.x = gameArea.x;
          red.vx = -red.vx;
        }
        if (red.x + red.width > gameArea.x + gameArea.width) {
          red.x = gameArea.x + gameArea.width - red.width;
          red.vx = -red.vx;
        }
        if (red.y < gameArea.y) {
          red.y = gameArea.y;
          red.vy = -red.vy;
        }
        if (red.y + red.height > gameArea.y + gameArea.height) {
          red.y = gameArea.y + gameArea.height - red.height;
          red.vy = -red.vy;
        }
      }
    
      for (let red of redObstacles) {
        if (collides(player, red)) {
          gameOver();
          return;
        }
      }
    
      if (collides(player, target)) {
        currentScore++;
        target.x = randomInt(objectMargin, screenWidth - objectMargin - target.width);
        target.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - target.height);
        for (let i = 0; i < redObstacles.length; i++) {
          let newRed = createRedObstacle();
          redObstacles[i].x = newRed.x;
          redObstacles[i].y = newRed.y;
          redObstacles[i].vx = randomChoice([-2, -1, 1, 2]);
          redObstacles[i].vy = randomChoice([-2, -1, 1, 2]);
        }
        let desiredCount = 2 + Math.floor(currentScore / 3);
        if (redObstacles.length < desiredCount) {
          let newRed = createRedObstacle();
          newRed.vx = randomChoice([-2, -1, 1, 2]);
          newRed.vy = randomChoice([-2, -1, 1, 2]);
          redObstacles.push(newRed);
        }
        draw();
        pauseUntil = performance.now() + 500;
        return;
      }
    
      let speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
      if (speed >= initialPlayerSpeed * maxSpeedMultiplier) {
        gameOver();
        return;
      }
    
      if (keys["b"] || keys["B"]) {
        let cx = player.x + player.width / 2;
        let cy = player.y + player.height / 2;
        player.width += 2;
        player.height += 2;
        player.x = cx - player.width / 2;
        player.y = cy - player.height / 2;
      }
      if (keys["t"] || keys["T"]) {
        if (player.width > 10 && player.height > 10) {
          let cx = player.x + player.width / 2;
          let cy = player.y + player.height / 2;
          player.width -= 2;
          player.height -= 2;
          player.x = cx - player.width / 2;
          player.y = cy - player.height / 2;
        }
      }
    }
    
    function draw() {
      ctx.clearRect(0, 0, screenWidth, screenHeight);
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      ctx.strokeStyle = "rgb(200,200,200)";
      ctx.strokeRect(gameArea.x, gameArea.y, gameArea.width, gameArea.height);
      ctx.fillStyle = "blue";
      ctx.fillRect(target.x, target.y, target.width, target.height);
      ctx.fillStyle = "red";
      for (let red of redObstacles) {
        ctx.fillRect(red.x, red.y, red.width, red.height);
      }
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.ellipse(player.x + player.width / 2, player.y + player.height / 2, player.width / 2, player.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      let scoreText = `Current Score: ${currentScore}    Previous Game Score: ${previousScore}    High Score: ${highScore}`;
      ctx.fillText(scoreText, 10, 30);
      
      // Draw the D-Pad in the dpadArea.
      ctx.strokeStyle = "black";
      ctx.strokeRect(dpadArea.x, dpadArea.y, dpadArea.width, dpadArea.height);
      ctx.beginPath();
      ctx.moveTo(dpadArea.x + dpadArea.width / 3, dpadArea.y);
      ctx.lineTo(dpadArea.x + dpadArea.width / 3, dpadArea.y + dpadArea.height);
      ctx.moveTo(dpadArea.x + 2 * dpadArea.width / 3, dpadArea.y);
      ctx.lineTo(dpadArea.x + 2 * dpadArea.width / 3, dpadArea.y + dpadArea.height);
      ctx.moveTo(dpadArea.x, dpadArea.y + dpadArea.height / 3);
      ctx.lineTo(dpadArea.x + dpadArea.width, dpadArea.y + dpadArea.height / 3);
      ctx.moveTo(dpadArea.x, dpadArea.y + 2 * dpadArea.height / 3);
      ctx.lineTo(dpadArea.x + dpadArea.width, dpadArea.y + 2 * dpadArea.height / 3);
      ctx.stroke();
      
      ctx.font = "20px Arial";
      ctx.fillStyle = "blue";
      ctx.fillText("←", dpadArea.x + dpadArea.width / 6 - 10, dpadArea.y + dpadArea.height / 2 + 7);
      ctx.fillText("→", dpadArea.x + 5 * dpadArea.width / 6 - 10, dpadArea.y + dpadArea.height / 2 + 7);
      ctx.fillText("↑", dpadArea.x + dpadArea.width / 2 - 10, dpadArea.y + dpadArea.height / 3 - 5);
      ctx.fillText("↓", dpadArea.x + dpadArea.width / 2 - 10, dpadArea.y + 2 * dpadArea.height / 3 + 20);
      ctx.fillText("■", dpadArea.x + dpadArea.width / 2 - 10, dpadArea.y + dpadArea.height / 2 + 7);
      
      ctx.font = "16px Arial";
      let instrY = dpadArea.y + dpadArea.height + 20;
      for (let instr of instructions) {
        ctx.fillText(instr, 10, instrY);
        instrY += 24;
      }
    }
    
    function pause(ms) {
      const start = performance.now();
      while (performance.now() - start < ms) { }
    }
    
    function gameOver() {
      previousScore = currentScore;
      if (currentScore > highScore) highScore = currentScore;
      resetGame();
    }
    
    function resetGame() {
      currentScore = 0;
      player.x = randomInt(gameArea.x + objectMargin, gameArea.x + gameArea.width - objectMargin - playerInitialWidth);
      player.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - playerInitialHeight);
      player.width = playerInitialWidth;
      player.height = playerInitialHeight;
      player.vx = 0;
      player.vy = 0;
      target.x = randomInt(objectMargin, screenWidth - objectMargin - targetSize);
      target.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - targetSize);
      redObstacles = [];
      for (let i = 0; i < 2; i++) {
        let red = createRedObstacle();
        red.vx = randomChoice([-2, -1, 1, 2]);
        red.vy = randomChoice([-2, -1, 1, 2]);
        redObstacles.push(red);
      }
    }
    
    function gameLoop() {
      let now = performance.now();
      let deltaTime = now - lastTime;
      lastTime = now;
      if (now < pauseUntil) {
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      let rectCanvas = canvas.getBoundingClientRect();
      let touchX = touch.clientX - rectCanvas.left;
      let touchY = touch.clientY - rectCanvas.top;
      if (touchY >= dpadArea.y) {
        processDpadTouch(touchX, touchY);
      } else {
        let centerX = player.x + player.width / 2;
        let centerY = player.y + player.height / 2;
        let dx = touchX - centerX;
        let dy = touchY - centerY;
        let len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          player.vx = (dx / len) * initialPlayerSpeed;
          player.vy = (dy / len) * initialPlayerSpeed;
        }
      }
    });
    
    canvas.addEventListener("touchmove", function(e) {
      e.preventDefault();
      let touch = e.touches[0];
      let rectCanvas = canvas.getBoundingClientRect();
      let touchX = touch.clientX - rectCanvas.left;
      let touchY = touch.clientY - rectCanvas.top;
      if (touchY >= dpadArea.y) {
        processDpadTouch(touchX, touchY);
      } else {
        let centerX = player.x + player.width / 2;
        let centerY = player.y + player.height / 2;
        let dx = touchX - centerX;
        let dy = touchY - centerY;
        let len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) {
          player.vx = (dx / len) * initialPlayerSpeed;
          player.vy = (dy / len) * initialPlayerSpeed;
        }
      }
    });
    
    gameLoop();
  </script>
</body>
</html>