<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Green Ball Game</title>
  <style>
    body { margin: 0; background: #eee; }
    canvas { display: block; margin: 0 auto; background: #fff; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1024" height="768"></canvas>
  <script>
    // Get canvas and context.
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Canvas dimensions.
    const screenWidth = canvas.width;
    const screenHeight = canvas.height;

    // Define margins.
    const topMargin = 50;       // Reserved for scores.
    const bottomMargin = 100;   // Reserved for instructions.
    const gameArea = { x: 0, y: topMargin, width: screenWidth, height: screenHeight - topMargin - bottomMargin };

    // Constants.
    const objectMargin = 20;   // Margin for objects inside the game area.
    const minDistance = 150;   // Red obstacles must be at least this far from the green ball.
    const targetSize = 20;
    const redSize = 20;
    const playerInitialWidth = 50;
    const playerInitialHeight = 50;
    const initialPlayerSpeed = 4;
    const bounceMultiplier = 1.1;
    const maxSpeedMultiplier = 5;  // End round if player's speed >= initialPlayerSpeed * 5

    // Game scores.
    let currentScore = 0;
    let previousScore = 0;
    let highScore = 0;

    // Define the player (green ball).
    let player = {
      x: randomInt(gameArea.x + objectMargin, gameArea.x + gameArea.width - objectMargin - playerInitialWidth),
      y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - playerInitialHeight),
      width: playerInitialWidth,
      height: playerInitialHeight,
      vx: 0,
      vy: 0
    };

    // Define the blue target.
    let target = {
      x: randomInt(objectMargin, screenWidth - objectMargin - targetSize),
      y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - targetSize),
      width: targetSize,
      height: targetSize
    };

    // Define an array for red obstacles.
    let redObstacles = [];
    // Initially create 2 red obstacles.
    for (let i = 0; i < 2; i++) {
      redObstacles.push(createRedObstacle());
    }

    // Key state.
    const keys = {};
    window.addEventListener("keydown", function(e) {
      keys[e.key] = true;
      // Quit the game if Q is pressed.
      if (e.key.toLowerCase() === "q") {
        cancelAnimationFrame(animationFrameId);
      }
    });
    window.addEventListener("keyup", function(e) {
      keys[e.key] = false;
    });

    // Add mobile touch support: when you tap, the green ball moves toward the tap.
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault(); // Prevent scrolling.
      let touch = e.touches[0];
      let rectCanvas = canvas.getBoundingClientRect();
      let touchX = touch.clientX - rectCanvas.left;
      let touchY = touch.clientY - rectCanvas.top;
      // Compute direction from player's center to the touch point.
      let centerX = player.x + player.width / 2;
      let centerY = player.y + player.height / 2;
      let dx = touchX - centerX;
      let dy = touchY - centerY;
      let len = Math.sqrt(dx * dx + dy * dy);
      if (len > 0) {
        player.vx = (dx / len) * initialPlayerSpeed;
        player.vy = (dy / len) * initialPlayerSpeed;
      }
    });

    // Helper: Returns a random integer between min and max (inclusive).
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Helper: Returns a random element from an array.
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    // Helper: Create a red obstacle (object) that is at least minDistance from the green ball.
    function createRedObstacle() {
      let red;
      while (true) {
        red = {
          x: randomInt(objectMargin, screenWidth - objectMargin - redSize),
          y: randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - redSize),
          width: redSize,
          height: redSize,
          vx: randomChoice([-2, -1, 1, 2]),
          vy: randomChoice([-2, -1, 1, 2])
        };
        let dx = (red.x + red.width/2) - (player.x + player.width/2);
        let dy = (red.y + red.height/2) - (player.y + player.height/2);
        let distance = Math.sqrt(dx*dx + dy*dy);
        if (distance >= minDistance) break;
      }
      return red;
    }

    // Collision detection.
    function collides(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // Global timing variables.
    let lastTime = performance.now();
    let animationFrameId;
    let pauseUntil = 0;

    // Expanded instructions for mobile and desktop.
    const instructions = [
      "How to Play:",
      "1. Navigate the green ball to touch the blue target.",
      "2. Each blue target gives you 1 point.",
      "3. Avoid the red balls drifting around; touching one ends the game.",
      "4. The green ball bounces off the walls, growing and speeding up.",
      "5. If the green ball's speed reaches 5Ã— its initial speed, the round ends.",
      "",
      "Controls:",
      "W / Arrow Up: Move Up",
      "S / Arrow Down: Move Down",
      "A / Arrow Left: Move Left",
      "D / Arrow Right: Move Right",
      "X: Stop Movement",
      "B: Increase size",
      "T: Decrease size",
      "Tap the screen (mobile) to move in that direction",
      "Q: Quit"
    ];

    // Main game loop.
    function gameLoop() {
      let now = performance.now();
      let deltaTime = now - lastTime;
      lastTime = now;

      if (now < pauseUntil) {
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Update game state.
    function update(deltaTime) {
      // Update player velocity based on keyboard input.
      if (keys["w"] || keys["W"] || keys["ArrowUp"]) {
        player.vx = 0;
        player.vy = -initialPlayerSpeed;
      } else if (keys["s"] || keys["S"] || keys["ArrowDown"]) {
        player.vx = 0;
        player.vy = initialPlayerSpeed;
      } else if (keys["a"] || keys["A"] || keys["ArrowLeft"]) {
        player.vy = 0;
        player.vx = -initialPlayerSpeed;
      } else if (keys["d"] || keys["D"] || keys["ArrowRight"]) {
        player.vy = 0;
        player.vx = initialPlayerSpeed;
      } else if (keys["x"] || keys["X"]) {
        player.vx = 0;
        player.vy = 0;
      }

      // Update player's position.
      player.x += player.vx;
      player.y += player.vy;

      // Bounce the player off the game area edges.
      if (player.x < gameArea.x) {
        player.x = gameArea.x;
        player.vx = -player.vx;
      }
      if (player.x + player.width > gameArea.x + gameArea.width) {
        player.x = gameArea.x + gameArea.width - player.width;
        player.vx = -player.vx;
      }
      if (player.y < gameArea.y) {
        player.y = gameArea.y;
        player.vy = -player.vy;
      }
      if (player.y + player.height > gameArea.y + gameArea.height) {
        player.y = gameArea.y + gameArea.height - player.height;
        player.vy = -player.vy;
      }

      // Check if the player hit an edge exactly.
      let bounced = false;
      if (player.x === gameArea.x || player.x + player.width === gameArea.x + gameArea.width) {
        bounced = true;
      }
      if (player.y === gameArea.y || player.y + player.height === gameArea.y + gameArea.height) {
        bounced = true;
      }
      if (bounced) {
        player.vx *= bounceMultiplier;
        player.vy *= bounceMultiplier;
        let cx = player.x + player.width / 2;
        let cy = player.y + player.height / 2;
        player.width = Math.floor(player.width * bounceMultiplier);
        player.height = Math.floor(player.height * bounceMultiplier);
        player.x = cx - player.width / 2;
        player.y = cy - player.height / 2;
      }

      // Update red obstacles: drift and bounce off game area edges.
      for (let red of redObstacles) {
        red.x += red.vx;
        red.y += red.vy;
        if (red.x < gameArea.x) {
          red.x = gameArea.x;
          red.vx = -red.vx;
        }
        if (red.x + red.width > gameArea.x + gameArea.width) {
          red.x = gameArea.x + gameArea.width - red.width;
          red.vx = -red.vx;
        }
        if (red.y < gameArea.y) {
          red.y = gameArea.y;
          red.vy = -red.vy;
        }
        if (red.y + red.height > gameArea.y + gameArea.height) {
          red.y = gameArea.y + gameArea.height - red.height;
          red.vy = -red.vy;
        }
      }

      // Check collision with red obstacles.
      for (let red of redObstacles) {
        if (collides(player, red)) {
          gameOver();
          return;
        }
      }

      // Check collision with the blue target.
      if (collides(player, target)) {
        currentScore++;
        // Reposition the blue target.
        target.x = randomInt(objectMargin, screenWidth - objectMargin - target.width);
        target.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - target.height);
        // Reposition all red obstacles with new velocities.
        for (let i = 0; i < redObstacles.length; i++) {
          let newRed = createRedObstacle();
          redObstacles[i].x = newRed.x;
          redObstacles[i].y = newRed.y;
          redObstacles[i].vx = randomChoice([-2, -1, 1, 2]);
          redObstacles[i].vy = randomChoice([-2, -1, 1, 2]);
        }
        // After each multiple of 3 points, add a new red obstacle.
        let desiredCount = 2 + Math.floor(currentScore / 3);
        if (redObstacles.length < desiredCount) {
          let newRed = createRedObstacle();
          newRed.vx = randomChoice([-2, -1, 1, 2]);
          newRed.vy = randomChoice([-2, -1, 1, 2]);
          redObstacles.push(newRed);
        }
        // Immediately update display so new positions are shown.
        draw();
        // Pause for 500 ms (half a second) after repositioning.
        pause(500);
      }

      // End round if player's speed reaches 5Ã— the initial speed.
      let speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
      if (speed >= initialPlayerSpeed * maxSpeedMultiplier) {
        gameOver();
        return;
      }

      // Continuous scaling with B and T keys.
      if (keys["b"] || keys["B"]) {
        let cx = player.x + player.width / 2;
        let cy = player.y + player.height / 2;
        player.width += 2;
        player.height += 2;
        player.x = cx - player.width / 2;
        player.y = cy - player.height / 2;
      }
      if (keys["t"] || keys["T"]) {
        if (player.width > 10 && player.height > 10) {
          let cx = player.x + player.width / 2;
          let cy = player.y + player.height / 2;
          player.width -= 2;
          player.height -= 2;
          player.x = cx - player.width / 2;
          player.y = cy - player.height / 2;
        }
      }
    }

    // Draw everything.
    function draw() {
      ctx.clearRect(0, 0, screenWidth, screenHeight);
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      ctx.strokeStyle = "rgb(200,200,200)";
      ctx.strokeRect(gameArea.x, gameArea.y, gameArea.width, gameArea.height);
      ctx.fillStyle = "blue";
      ctx.fillRect(target.x, target.y, target.width, target.height);
      ctx.fillStyle = "red";
      for (let red of redObstacles) {
        ctx.fillRect(red.x, red.y, red.width, red.height);
      }
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.ellipse(player.x + player.width / 2, player.y + player.height / 2, player.width / 2, player.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      let scoreText = `Current Score: ${currentScore}    Previous Game Score: ${previousScore}    High Score: ${highScore}`;
      ctx.fillText(scoreText, 10, 30);
      ctx.font = "16px Arial";
      let y = screenHeight - bottomMargin + 20;
      for (let instr of instructions) {
        ctx.fillText(instr, 10, y);
        y += 24;
      }
    }

    // Simple busy-wait pause.
    function pause(ms) {
      const start = performance.now();
      while (performance.now() - start < ms) { }
    }

    // Game over: update scores and reset the game.
    function gameOver() {
      previousScore = currentScore;
      if (currentScore > highScore) highScore = currentScore;
      resetGame();
    }

    // Reset game variables for a new round.
    function resetGame() {
      currentScore = 0;
      player.x = randomInt(gameArea.x + objectMargin, gameArea.x + gameArea.width - objectMargin - playerInitialWidth);
      player.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - playerInitialHeight);
      player.width = playerInitialWidth;
      player.height = playerInitialHeight;
      player.vx = 0;
      player.vy = 0;
      target.x = randomInt(objectMargin, screenWidth - objectMargin - targetSize);
      target.y = randomInt(gameArea.y + objectMargin, gameArea.y + gameArea.height - objectMargin - targetSize);
      redObstacles = [];
      for (let i = 0; i < 2; i++) {
        let red = createRedObstacle();
        red.vx = randomChoice([-2, -1, 1, 2]);
        red.vy = randomChoice([-2, -1, 1, 2]);
        redObstacles.push(red);
      }
    }

    // Start the game loop.
    function gameLoop() {
      let now = performance.now();
      let deltaTime = now - lastTime;
      lastTime = now;
      if (now < pauseUntil) {
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
        return;
      }
      update(deltaTime);
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
